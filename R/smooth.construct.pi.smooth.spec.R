#' Parametric interaction basis constructor
#' 
#' The \code{pi} basis is appropriate for smooths of multiple variables. Its 
#' purpose is to parameterize the way in which the basis changes with one of
#' those variables. For example, suppose the smooth is over three variables,
#' \eqn{x}, \eqn{y}, and \eqn{t}, and we want to parameterize the effect of
#' \eqn{t}. Then the \code{pi} basis will assume \eqn{f(x,y,t) = \sum_k
#' g_k(t)*f_k(x,y)}, where the \eqn{g_k(t)} functions are pre-specified and the
#' \eqn{f_k(x,y)} functions are estimated using a bivariate basis. An example of
#' a parametric interaction is a linear interaction, which would take the form 
#' \eqn{f(x,y,t) = f_1(x,y) + t*f_2(x,y)}.
#' 
#' All functions \eqn{f_k()} are defined using the same basis set.
#' Accordingly, they are penalized using a single block-diagonal penalty matrix
#' and one smoothing parameter. Future versions of this function may be able
#' to relax this assumption.
#' 
#' @param object a smooth specification object, generated by, e.g.,
#'    \code{s(x, y, t, bs="pi", xt=list(tf=list(g1, g2, g3)))}. For
#'    transformation functions \code{g1}, \code{g2}, and \code{g3}, see
#'    Details below.
#' @param data a list containing the variables of the smooth (\code{x},
#'    \code{y}, and \code{t} above), as well as any \code{by} variable.
#    The first variable will
#    be the index of the \eqn{f_k} functions (\code{x} above), and the second 
#    will be the interacting variable (\code{t} above). The \code{by} variable
#    is the last element.
#' @param knots a list containing any knots supplied for basis setup - in same
#'    order and with same names as \code{data}. Can be \code{NULL}.
#' 
#' @details
#' The smooth specifiation object, defined using \code{s()}, must contain an
#' \code{xt} argument. The object assigned to \code{xt} defines the
#' transformation functions (\eqn{g_k(t)} in the above notation), and can
#' take one of the following forms:
#' 
#' \enumerate{
#'   \item A list of transformation functions, each with one argument \eqn{t}
#'   \item One of the following character strings: \code{"linear"},
#'   \code{"quadratic"}, or \code{"none"}, which are shortcuts to define bases
#'   with linear, quadratic, and no interaction, respectively
#'   \item A list that can contain the following elements: \code{tf}, \code{bs},
#'   \code{idx}, and \code{xt}. \code{xt$tf} (required) must take one of the
#'   above forms to define the transformation functions. \code{xt$bs} can
#'   specify the basis for the functions \eqn{f_k()}. \code{xt$idx} is a numeric
#'   index indicating which variable from \code{object$term} is to be
#'   parameterized. \code{xt$xt} supplies the \code{xt} argument to the basis
#'   for the functions \eqn{f_k()}.
#' }
#' 
#' The default is that the variable to be parameterized will be the last one
#' in \code{object$term}, and for a \code{"tp"} basis to be used for the
#' functions \eqn{f_k()}. These can be overriden by setting \code{xt$idx} and
#' \code{xt$bs}, respectively, as described above.
#' Additional options for the univariate basis such as dimension and order of
#' the penalty can be specified using the corresponding arguments of \code{s()}
#' in the definition of the smooth specification object. For example,
#' \code{s(x, t, bs="pi", k=15, xt=list(tf="linear", bs="ps"))}
#' will define a linear interaction with \code{t} of a univariate p-spline
#' basis of dimension 15 over \code{x}.
#' 
# The smooth specification object, defined using \code{s()}, must contain an
# \code{xt} argument. This argument is a list with, at minimum, a \code{tf}
# element that defines the transformation functions (\eqn{g_k(t)} in the above
# notation). The \code{tf} element can either be a list of functions, or
# alternatively as one of the following character strings: \code{"linear"},
# \code{"quadratic"}, or \code{"none"} for bases with linear, quadratic, and
# no interaction, respectively.
# 
# The default settings for the univariate basis for the functions \eqn{f_k(x)}
# are the same as the defaults for \code{s()}: a thin-plate regression spline
# basis of dimension 10. These defaults can be overridden by adding elements
# to the \code{xt} list. For example, to define a linear interaction basis
# using p-splines of dimension 15, the code would be
# \code{s(x, t, bs="pi", xt=list("linear", bs="ps", k=15))}.
# 
# An alternative way to specify these basis options is to use the arguments
# of \code{s()} instead of as elements of \code{xt}. The exception is the basis
# type, which can only be set within \code{xt} because \code{bs="pi"} within
# \code{s()}. If the basis option is defined in both places, the setting
# within \code{xt} will be used. For example, either
# \code{s(x, t, bs="pi", k=15, xt=list("linear", bs="ps"))} or
# \code{s(x, t, bs="pi", k=20, xt=list("linear", bs="ps", k=15))}
# will define the p-spline basis of dimension 15.
# 
# This object contains at minimum the information
# defining the transformation functions (\eqn{g_k(t)} in the above notation).
# This information can be entered as a list of functions of \eqn{t}, or
# alternatively as one of the following character strings: \code{"linear"},
# \code{"quadratic"}, or \code{"none"} for bases with linear, quadratic, and
# no interaction, respectively.
# 
# The default basis for the univariate functions \eqn{f_k(x)} is a thin-plate
# regression spline basis. If a different basis is desired, then it must be
# specified using \code{xt}. In this case, \code{xt} must be a list, and it
# will contain an element \code{bs} that specifies the basis (see
# \code{\link[mgcv]{s}}). The information that defines the transformation
# functions (either a one of the above character strings or the individual
# functions) should remain unnamed.
# 
# Any additional options for the univariate basis can be specified using either
# the associated arguments in the call to \code{s()}, or as arguments of the
# \code{xt} list. If both are specified, then the specification in \code{xt}
# will override the one in the \code{s()} argument. Note that the reason the
# basis cannot be defined using the argument in \code{s()} is because this
# argument will already be specified as \code{bs="pi"}.
# 
# For example, to define a linear interaction basis using p-splines
# of dimension 15, the code could either be
# \code{s(x, t, bs="pi", xt=list("linear", bs="ps", k=15))} or
# \code{s(x, t, bs="pi", k=15, xt=list("linear", bs="ps"))}. If the default
# thin-plate regression splines are desired, the specification could be
# \code{s(x, t, bs="pi", k=15, xt="linear")}.
# 
#' @author Fabian Scheipl and Jonathan Gellar
#' @return An object of class "pi.smooth". See
#'    \code{\link[mgcv]{smooth.construct}} for the elements it will contain.
#' 

smooth.construct.pi.smooth.spec <- function(object, data, knots) {
  # Constructor method for parametric bivariate basis
  
  # Input Checks
  if (length(object$term) < 2)
    stop("\"pi\" smooth must have at least two variables")
  
  # Extract tf functions, basis, and index
  xt <- object$xt
  bs = newxt <- NULL
  idx <- length(object$term)
  if (is.character(xt)) {
    tf <- xt
  } else if (is.list(xt)) {
    if (is.null(xt$tf)) {
      tf <- xt
    } else {
      if (!all(names(xt) %in% c("tf", "bs", "xt", "idx")))
        warning("Ignoring unrecognized elements of \"xt\"")
      tf <- xt$tf
      bs <- xt$bs
      newxt <- xt$xt
      if (!is.null(xt$idx)) idx <- xt$idx
    }
  } else stop("xt must be a character string or list")
  
  # Convert tf to functions
  if (is.character(tf)) {
    if (tf=="none")
      tf <- list(function(t) t^0)
    else if (tf=="linear")
      tf <- list(function(t) t^0, function(t) t^1)
    else if (tf=="quadratic")
      tf <- list(function(t) t^0, function(t) t^1, function(t) t^2)
    else stop("Unrecognized character string for transformation functions")
  } else if (is.list(tf)) {
    if (any(sapply(tf, class) != "function"))
      stop("Incorrect input for transformation functions")
  } else stop("Incorrect input for transformation functions")
  
  # Extract tvar based on idx
  tvar <- data[[object$term[idx]]]
  dat  <- data[object$term[-idx]]
  
  # Set up design for t
  n_transform <- length(tf)
  tf_name <- paste0(object$term[idx], "_tf_", 1:n_transform)
  t_X <-  vapply(tf, function(f)
    do.call(f, list(t=tvar)), numeric(length(tvar)))
  
  # set up smooth over x
  args <- list(k=object$bs.dim, fx=object$fixed, m=object$p.order,
               xt=newxt, id=object$id, sp=object$sp)
  if (!is.null(bs)) args$bs <- bs
  if (object$by!="NA") {
    args$by <- data[[object$by]]
    dat[[object$by]] <- data[[object$by]]
  }
  callargs <- sapply(object$term[-idx], as.name)
  names(callargs) <- NULL
  smoothspec <- do.call(mgcv::s, append(callargs, args))
  sm0 <- smooth.construct(smoothspec, data = dat, knots = knots)
  
  # Modify smooth term:
  sm <- sm0
  sm$term <- c(object$term[-idx], object$term[idx])
  sm$bs.dim <-  sm$bs.dim * n_transform
  sm$null.space.dim <-  sm$null.space.dim * n_transform
  sm$df <- sm$df * n_transform
  sm$dim <- length(object$term)
  sm$label <- paste0("f(", object$term[idx], ")*", sm$label)
  sm$xt <- object$xt
  sm$X <- mgcv::tensor.prod.model.matrix(list(t_X, sm$X))
  sm$S[[1]] <- diag(n_transform) %x% sm$S[[1]]
  sm$bs <- strsplit(class(smoothspec), ".", fixed=T)[[1]][1]
  sm$tf <- tf
  sm$sm <- sm0
  
  ## ctrl-c-v from smooth.construct.tp.smooth.spec:
  if (!is.null(sm$drop.null)) {
    if (sm$drop.null > 0) {
      ind <- 1:(sm$bs.dim - sm$null.space.dim)
      if (FALSE) { ## nat param version
        np <- nat.param(sm$X, sm$S[[1]], rank=sm$bs.dim - sm$null.space.dim,
                        type=0)
        sm$P <- np$P
        sm$S[[1]] <- diag(np$D)
        sm$X <- np$X[,ind]
      } else { ## original param
        sm$S[[1]] <-sm$S[[1]][ind,ind]
        sm$X <-sm$X[, ind]
        sm$cmX <- colMeans(object$X)
        sm$X <- sweep(object$X, 2, object$cmX)
      }
      sm$null.space.dim <- 0
      sm$df <- sm$df - M
      sm$bs.dim <-sm$bs.dim -M
      sm$C <- matrix(0,0,ncol(object$X)) # null constraint matrix
    }
  }
  class(sm) <- "pi.smooth"
  sm
}



#' Predict.matrix method for pi basis

Predict.matrix.pi.smooth <- function(object, data) {
  # Prediction method for parameteric bivariate basis
  
  # Separate tvar from data
  idx  <- length(object$term)
  tvar <- data[[object$term[idx]]]
  dat  <- data[-idx]
  
  # Set up design for t
  t_X <-  vapply(object$tf, function(f)
    do.call(f, list(t=tvar)), numeric(length(tvar)))
  
  # Evaluate object$sm at new locations
  pmat <- Predict.matrix(object = object$sm, data = dat)
  
  # Return tensor product with t_X
  mgcv::tensor.prod.model.matrix(list(t_X, pmat))
}
