% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/smooth.construct.pi.smooth.spec.R
\name{smooth.construct.pi.smooth.spec}
\alias{smooth.construct.pi.smooth.spec}
\title{Parametric interaction basis constructor}
\usage{
\method{smooth.construct}{pi.smooth.spec}(object, data, knots)
}
\arguments{
\item{object}{a smooth specification object, generated by, e.g.,
\code{s(x, y, t, bs="pi", xt=list(tf=list(g1, g2, g3)))}. For
transformation functions \code{g1}, \code{g2}, and \code{g3}, see
Details below.}

\item{data}{a list containing the variables of the smooth (\code{x},
\code{y}, and \code{t} above), as well as any \code{by} variable.}

\item{knots}{a list containing any knots supplied for basis setup - in same
   order and with same names as \code{data}. Can be \code{NULL}.}
}
\value{
An object of class "pi.smooth". See
   \code{\link[mgcv]{smooth.construct}} for the elements it will contain.
}
\description{
The \code{pi} basis is appropriate for smooths of multiple variables. Its
purpose is to parameterize the way in which the basis changes with one of
those variables. For example, suppose the smooth is over three variables,
\eqn{x}, \eqn{y}, and \eqn{t}, and we want to parameterize the effect of
\eqn{t}. Then the \code{pi} basis will assume \eqn{f(x,y,t) = \sum_k
g_k(t)*f_k(x,y)}, where the \eqn{g_k(t)} functions are pre-specified and the
\eqn{f_k(x,y)} functions are estimated using a bivariate basis. An example of
a parametric interaction is a linear interaction, which would take the form
\eqn{f(x,y,t) = f_1(x,y) + t*f_2(x,y)}.
}
\details{
All functions \eqn{f_k()} are defined using the same basis set.
Accordingly, they are penalized using a single block-diagonal penalty matrix
and one smoothing parameter. Future versions of this function may be able
to relax this assumption.

The smooth specifiation object, defined using \code{s()}, must contain an
\code{xt} element The object assigned to \code{xt} defines the
transformation functions (\eqn{g_k(t)} in the above notation), and can
take one of the following forms:

\enumerate{
  \item A list of transformation functions, each with one argument \eqn{t}
  \item One of the following character strings: \code{"linear"},
  \code{"quadratic"}, or \code{"none"}, which are shortcuts to define bases
  with linear, quadratic, and no interaction, respectively
  \item A list that can contain the following elements: \code{tf}, \code{bs},
  \code{idx}, and \code{xt}. \code{xt$tf} (required) must take one of the
  above forms to define the transformation functions. \code{xt$bs} can
  specify the basis for the functions \eqn{f_k()}. \code{xt$idx} is a numeric
  index indicating which variable from \code{object$term} is to be
  parameterized. \code{xt$xt} supplies the \code{xt} argument to the basis
  for the functions \eqn{f_k()}.
}

The default is that the variable to be parameterized will be the last one
in \code{object$term}, and for a \code{"tp"} basis to be used for the
functions \eqn{f_k()}. These can be overriden by setting \code{xt$idx} and
\code{xt$bs}, respectively, as described above.
Additional options for the univariate basis such as dimension and order of
the penalty can be specified using the corresponding arguments of \code{s()}
in the definition of the smooth specification object. For example,
\code{s(x, t, bs="pi", k=15, xt=list(tf="linear", bs="ps"))}
will define a linear interaction with \code{t} of a univariate p-spline
basis of dimension 15 over \code{x}.
}
\author{
Fabian Scheipl and Jonathan Gellar
}

